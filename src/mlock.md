# 如何给SGX添加mlock功能

在linux中，mlock是一个系统调用，可以`man mlock` 查看。 简单的说，就是防止一段内存所在的页，被交换到交换区中。

在sgx中，mlock的含义是防止一个页从EPC被交换到DRAM中。在intel的sgx中，并没有这个功能，而在有些场景下，我们还是需要这个功能的（但是我并不知道这个场景在哪里）。所以我们需要修改相关代码，以支持mlock功能。

首先要锁住一个EPC页，就意味着在寻找要被交换出去的页的时候，要忽略这些页。每个页都有一些flag.我们在flag中添加一个MLOCK属性。swap-scanning的时候忽略MLOCK的页，这个页就不会被交换出去了。

然后程序如何和 `/dev/isgx` 通信，告诉 `/dev/isgx` 哪个页要添加标记呢？我们可以在linux-sgx的仓库中搜索 ioctl,发现在psw中有许多ioctl的代码，以葫芦画瓢就行了

由于要ioctl,而ioctl是无法在sgx内执行的，本质上这是一个ocall,不是非常安全。

这种改法，使得开发者要调用mlock非常方便，只需要在edl中加一个 import就行。

注意，这种写法只会影响交换，不会影响释放。在Enclave退出时， 所有页都一定会释放的

我主要参考的是 sgx_oc_cpuidex 这个函数的出现位置

sgx_oc_mlock 
0： 成功
<0: error 


注意需要把地址的偏移量（最后12位）给抹掉，不抹掉 linux-sgx-driver是不会响应请求的。
很明显要在sgx内就抹掉

## mlockd的应用场景
在linux中，mlock主要在安全上有效果：比如一个密码，在内存中是安全的（why？），不过一旦swap到磁盘上，会被窃取。可能磁盘不会清空，也可能在运行态就被攻击了。
所以可以对swap加密，加密的秘钥显然要是随机的。但是又有新的问题，电脑休眠后，加密的秘钥可能会丢失，到时swap恢复不出来

在sgx中，swap出来的时候已经加密了。而且由于不会dump到磁盘上，基于磁盘的攻击也难以实现。所以安全上作用不大

所以mlock的应用场景：需要效率，要求比lru更高的命中率

-------
# 如何使用
mlock(address): 锁住地址所在的页
munlock(address): 解锁地址所在的页
mincore(address)： 查看地址所在的页是否被锁住了

# 缺陷
1. mlock会影响换入换出性能。锁住的页越多，查询换出的页就要花费更多的时间
2. mlock有上限。上限是EPC的总可使用内存量。这个值小于128M,大约在90M左右
